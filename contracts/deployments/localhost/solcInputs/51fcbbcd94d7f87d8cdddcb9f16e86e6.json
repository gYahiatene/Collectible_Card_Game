{
  "language": "Solidity",
  "sources": {
    "src/Main.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8;\n\nimport \"./Collection.sol\";\n\ncontract Main {\n  address private owner;\n  uint public count;\n  uint public cardCount;\n  mapping(uint => Collection) private collections;\n  mapping(uint => Card) private cards;\n\n  constructor() {\n    owner = 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266;\n    count = 0;\n    cardCount = 0;\n  }\n\n  function createCollection(string calldata name, uint cardCount, string memory imageURI) external returns (uint) {\n        require(msg.sender == owner, \"You are not allowed to call this function.\");\n        collections[count] = new Collection(name, cardCount, count, imageURI);\n        count++;\n        return count - 1;\n    }\n\n  function createCardInCollection(uint collectionId, string memory cardName, string memory imageUrl) external {\n      require(msg.sender == owner, \"You are not allowed to call this function.\");\n      require(address(collections[collectionId]) != address(0), \"collectionId not defined\");\n      Collection selectedCollection = collections[collectionId];\n      \n      // Appel de createCard avec l'adresse du créateur comme argument\n      Card newCard = selectedCollection.createCard(cardName, imageUrl, cardCount, owner);  \n      cards[cardCount] = newCard; \n      cardCount++;\n  }\n\n  function getCollection(Collection _collection) external view returns (uint, string memory, uint, string memory) {\n      require(msg.sender == owner, \"You are not allowed to call this function.\");\n      return (_collection.getId(), _collection.getName(), _collection.getCardCount(), _collection.getImageURI());\n  }\n\n  function getAllCollections() external view returns (Collection[] memory) {\n    require(msg.sender == owner, \"You are not allowed to call this function.\");\n    Collection[] memory allCollections = new Collection[](count);\n    for (uint i = 0; i < count; i++) {\n        allCollections[i] = collections[i];\n    }\n    return allCollections;\n  }\n\n  function getCardOfCollection(uint collectionId) external view returns (Card[] memory){\n    require(msg.sender == owner, \"You are not allowed to call this function.\");\n    require(address(collections[collectionId]) != address(0), \"Collection not found.\");\n    return collections[collectionId].getCards();\n  }\n\n  function getCardInfo(Card _card) external view returns (uint, string memory, string memory){\n    require(msg.sender == owner, \"You are not allowed to call this function.\");\n    return (_card.getIdCard(), _card.getNameCard(), _card.getImageURI());\n  }\n\n  function getOwnerOf(uint idCard) external view returns (address) {\n    return cards[idCard].ownerOf(idCard);\n  }\n\n  function transferCard(uint cardId, address to) external payable {\n    require(msg.value == 1 ether, \"You must send exactly 1 ETH for the transfer\");\n    require(address(cards[cardId]) != address(0), \"Card not defined\");\n    require(cards[cardId].ownerOf(cardId) == msg.sender, \"You do not own this card\");\n\n    // Transfert de l'ETH au propriétaire actuel de la carte\n    (bool sent, ) = to.call{value: msg.value}(\"\");\n    require(sent, \"Failed to send ETH to the recipient\");\n\n    // Transfert de la carte\n    cards[cardId].transferFrom(msg.sender, to, cardId);\n  }\n  \n  function getAllCard() external view returns (uint){\n    return cardCount;\n  }\n\n  function getCardInfoById(uint id) external view returns (string memory, string memory, uint){\n    return (cards[id].getNameCard(), cards[id].getImageURI(), id);\n  }\n  \n}\n"
    },
    "src/Collection.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8;\n\nimport \"./Card.sol\";\n\ncontract Collection {\n    string public name;\n    uint public cardCount;\n    uint private idCollection;\n    Card[] private setCard;\n    string private imageURI;\n  \n    constructor(string memory _name, uint _cardCount, uint _idCollection, string memory _imageURI) {\n        name = _name;\n        cardCount = _cardCount;\n        idCollection = _idCollection;\n        imageURI = _imageURI;\n    }\n\n    function createCard(string memory _cardName, string memory _imageUrl, uint cardId, address creator) public returns (Card) {\n        require(setCard.length < cardCount, \"Le nombre de cartes a atteint sa limite.\"); \n        Card newCard = new Card(_cardName, _imageUrl, cardId, creator);  // Ajout de 'creator' comme paramètre\n        setCard.push(newCard);\n        return newCard;\n    }\n\n    function getCards() public view returns (Card[] memory) {\n        return setCard;\n    }\n\n    function getName() public view returns (string memory) {\n        return name;\n    }\n\n    function getCardCount() public view returns (uint) {\n        return cardCount;\n    }\n\n    function getId() public view returns (uint) {\n        return idCollection;\n    }\n\n    function getImageURI() public view returns (string memory) {\n        return imageURI; \n    }\n}\n"
    },
    "src/Card.sol": {
      "content": "    // SPDX-License-Identifier: MIT\n    pragma solidity ^0.8;\n\n    interface IERC721{\n        \n        function balanceOf(address owner) external view returns (uint balance);\n\n        function ownerOf(uint tokenId) external view returns (address owner);\n\n        function safeTransferFrom(address from, address to, uint tokenId) external;\n\n        function safeTransferFrom(address from, address to, uint tokenId, bytes calldata data) external;\n\n        function transferFrom(address from, address to, uint tokenId) external;\n\n        function approve(address to, uint tokenId) external;\n\n        function getApproved(uint tokenId) external view returns (address operator);\n\n        function setApprovalForAll(address operator, bool _approved) external;\n\n        function isApprovedForAll( address owner, address operator) external view returns (bool);\n    }\n\n    interface IERC721Receiver {\n        function onERC721Received(address operator, address from, uint tokenId, bytes calldata data) external returns (bytes4);\n    }\n\n    contract ERC721 is IERC721 {\n        event Transfer(address indexed from, address indexed to, uint indexed id);\n        event Approval(address indexed owner, address indexed spender, uint indexed id);\n        event ApprovalForAll(address indexed owner, address indexed operator,bool approved);\n\n        // Mapping from token ID to owner address\n        mapping(uint => address) internal _ownerOf;\n\n        // Mapping owner address to token count\n        mapping(address => uint) internal _balanceOf;\n\n        // Mapping from token ID to approved address\n        mapping(uint => address) internal _approvals;\n\n        // Mapping from owner to operator approvals\n        mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n        function ownerOf(uint id) public view returns (address owner) {\n            owner = _ownerOf[id];\n            require(owner != address(0), \"token doesn't exist\");\n            return owner; \n        }\n\n        function balanceOf(address owner) external view returns (uint) {\n            require(owner != address(0), \"owner = zero address\");\n            return _balanceOf[owner];\n        }\n\n        function setApprovalForAll(address operator, bool approved) external {\n            isApprovedForAll[msg.sender][operator] = approved;\n            emit ApprovalForAll(msg.sender, operator, approved);\n        }\n\n        function approve(address spender, uint id) external {\n            address owner = _ownerOf[id];\n            require(\n                msg.sender == owner || isApprovedForAll[owner][msg.sender],\n                \"not authorized\"\n            );\n\n            _approvals[id] = spender;\n\n            emit Approval(owner, spender, id);\n        }\n\n        function getApproved(uint id) external view returns (address) {\n            require(_ownerOf[id] != address(0), \"token doesn't exist\");\n            return _approvals[id];\n        }\n\n        function _isApprovedOrOwner(address owner, address spender, uint id) internal view returns (bool) {\n            return (spender == owner || isApprovedForAll[owner][spender] || spender == _approvals[id]);\n        }\n\n        function transferFrom(address from, address to, uint id) public {\n            require(from == _ownerOf[id], \"from != owner\");\n            require(to != address(0), \"transfer to zero address\");\n        \n            _balanceOf[from]--;\n            _balanceOf[to]++;\n            _ownerOf[id] = to;\n\n            delete _approvals[id];\n\n            emit Transfer(from, to, id);\n        }\n\n        function safeTransferFrom(address from, address to, uint id) external {\n            transferFrom(from, to, id);\n\n            require(\n                to.code.length == 0 ||\n                    IERC721Receiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                    IERC721Receiver.onERC721Received.selector,\n                \"unsafe recipient\"\n            );\n        }\n\n        function safeTransferFrom(\n            address from,\n            address to,\n            uint id,\n            bytes calldata data\n        ) external {\n            transferFrom(from, to, id);\n\n            require(\n                to.code.length == 0 ||\n                    IERC721Receiver(to).onERC721Received(msg.sender, from, id, data) ==\n                    IERC721Receiver.onERC721Received.selector,\n                \"unsafe recipient\"\n            );\n        }\n\n        function _mint(address to, uint id) internal {\n            require(to != address(0), \"mint to zero address\");\n            require(_ownerOf[id] == address(0), \"already minted\");\n\n            _balanceOf[to]++;\n            _ownerOf[id] = to;\n\n            emit Transfer(address(0), to, id);\n        }\n\n        function _burn(uint id) internal {\n            address owner = _ownerOf[id];\n            require(owner != address(0), \"not minted\");\n\n            _balanceOf[owner] -= 1;\n\n            delete _ownerOf[id];\n            delete _approvals[id];\n\n            emit Transfer(owner, address(0), id);\n        }\n    }\n\n   \n    contract Card is ERC721 {\n        string private nameCard;\n        string private imageURI; \n        uint private cardId;    \n\n        constructor(string memory _nameCard, string memory _imageURI, uint _cardId, address creator) {\n            nameCard = _nameCard;\n            imageURI = _imageURI;\n            cardId = _cardId;\n            _mint(creator, _cardId);  // Propriétaire assigné lors de la création\n        }   \n\n        function getIdCard() public view returns (uint) {\n            return cardId;\n        }   \n\n        function getNameCard() public view returns (string memory) {\n            return nameCard;\n        }   \n\n        function getImageURI() public view returns (string memory) {\n            return imageURI; \n        }\n    }   \n\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}